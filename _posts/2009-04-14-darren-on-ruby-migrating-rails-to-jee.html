---
layout: post
title: 'Darren on Ruby: Migrating Rails to Tomcat / JEE, Part 2: Migrating Your Data
  From SQLite3 to Derby'
date: '2009-04-14T11:29:00.007+01:00'
author: Darren Bishop
tags:
- Derby
- Java
- Rails
- JRoR
- Tomcat
- SQLite3
- JRuby
- Ruby
- RoR
modified_time: '2009-05-01T12:48:06.698+01:00'
blogger_id: tag:blogger.com,1999:blog-3826577489563855618.post-7739743062181556885
blogger_orig_url: http://blog.darrenbishop.com/2009/04/darren-on-ruby-migrating-rails-to-jee.html
---

<h4>The Series So Far</h4>
<p>
<a href="http://workingwithmrb.blogspot.com/2009/04/migrating-rails-to-jee-part-1-switching.html" target="_blank">Part 1: Switching to JRuby &amp; Apache Derby</a> showed you how to migrate from the Ruby+SQLite3 technology stack to JRuby+Derby.
</p>
<p>
Now we will take a look at migrating the important stuff: your data.

I found two ways to do a data migration: the easy way and the hard way. And unfortunately for me, I found the hard way first.
</p>
<blockquote>
<h3>Update, 01/05/2009: You Don't Really Need to Migrate to Derby</h3>
You can continue to use SQLite3 if it so pleases you. You just need to install the necessary gems i.e. jdbc-adapter:

<pre class="brush: bash">
jgem install activerecord-jdbcsqlite3-adapter -y
</pre>

The other thing is that it seems that SQLite3 allows you to use names for entities that are keywords in Derby e.g. <i>min</i> or <i>max</i>. Check <a href="http://publib.boulder.ibm.com/infocenter/wasinfo/v7r0/index.jsp?topic=/com.ibm.etools.ejbbatchdeploy.doc/topics/rsqlDERBY_V101.html">here</a> for a list of keywords used by Derby.
</blockquote>
<p>
<h4>Do It The Easy Way, Do It The Ruby Way</h4>
To facilitate the easy way, we need to install the AR_Fixtures Rails plugin (not quite sure why this isn't a Gem, thus making it available to all Rails apps).
<pre class="brush: bash">ruby script\plugin install http://topfunky.net/svn/plugins/ar_fixtures</pre>
This plugin gives us the <code>db:fixtures:dump</code> Rake task. As you'll see next it understands the <code>MODEL</code> and <code>RAILS_ENV</code> commandline/environment variables. It can't dump the entire database, strangely enough.
</p>
<p>
For this first step you need to go back to <code>RAILS_ROOT\config\database.yml</code>, disable (prepend an underscore) the jdbc development spec and re-enable the sqlite3 development spec. Then run the following commands:
<pre class="brush: bash">
rake db:fixtures:dump MODEL=Post
rake db:fixtures:dump MODEL=Comment
rake db:fixtures:dump MODEL=Tag
</pre>
Take a look in <code>RAILS_ROOT\test\fixtures</code>; you should see <code>posts.yml</code>, <code>comments.yml</code> and <code>tags.yml</code>.
</p>
<p>
Now change you <code>RAILS_ROOT\config\database.yml</code> file to point to the jdbc development spec again, then run:
<pre class="brush: bash">
jrake db:migrate
jrake db:fixtures:load
</pre>

You should now be good to go - start up your app using JRuby and test the blog data was migrated by going <a href="http://localhost:3000/posts" target="_blank">here</a>.
</p>
<p>
<h4>Do It The Hard Way, Do It The Way I Did It When I Didn't Know The Easy Way</h4>
<h5>...Also The Way To Do It If Your Data Isn't Entirely Managed By ActiveRecord</h5>
<ol>
<li>Export SQLite3 Data:
<ul>
<li>Run <code>sqlite3 development.sqlite3 .dump >> development_dump.sql</code> in <code>RAILS_ROOT\db</code></li>
</ul>
</li>
<li>Tidy-up SQL Dump:
<ul>
<li>Open <code>development_dump.sql</code> in a text editor and make the following changes:</li>
<li>Remove any DDL or DML commands to do with the <code>sqlite_sequence</code> table</li>
<li>Remove any DDL or DML commands to do with the <code>schema_migrations</code> table, including the index</li>
<li>Unquote all table names e.g. change <code>CREATE TABLE "posts" ...</code> to <code>CREATE TABLE posts ...</code></li>
<li>Replace <code>AUTOINCREMENT NOT NULL</code> with <code>NOT NULL GENERATED BY DEFAULT AS IDENTITY</code></li>
<li>Replace <code>datetime</code> with <code>timestamp</code></li>
<li>Replace <code>integer\([0-9]*\)</code> with <code>integer</code></li>
<li>Replace <code>text</code> with <code>long varchar</code></li>
<li>Replace <code>DEFAULT ([0-9]*|NULL) NULL</code> with <code>DEFAULT NULL</code></li>
<li>Also be sure that any <code>varchar(255)</code> table columns only have that many characters, or else the import will complain and truncate your data (in this case, your precious blogs).<br />
If <code>varchar(255)</code> is not big enough, just switch it to <code>long varchar</code></li>
</ul>
</li>
<li>Import into Derby:
<ul>
<li>Run <code>ij</code> (the Derby command-line client) in <code>RAILS_ROOT\db</code></li>
<li>Run the following commands in <code>ij</code>:
<pre class="brush: sql">
connect 'jdbc:derby:blog_development;create=true' as dev;
run 'development_dump.sql';
exit;
</pre>
</li>
</ul>
</li>
</ol>
</p>
<p>
That should be it; you should have seen each model-table being created followed by the corresponding blog data going into Derby. You might see some <em>'Table already exists'</em> errors when the DDL statements execute; these will occur if you previously ran <code>jrake db:migrate</code>, which creates the tables for you - just ignore them.

Run the server again using JRuby and you should be able to access your blogs again.
</p>
<p>
<h4>What's Next?</h4>
Next I will step through the procedure to package your Rails application to a Web ARchive file, ready to deploy to Tomcat, Jetty or any JEE/Servlet container of your choice. You can catch that blog <a href="" target="_blank">here</a>
<br/ >
<br/ >
Cheers
</p>